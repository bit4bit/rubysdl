= Video
TOC

SDL は表示フレームバッファに対するとてもシンプルなインターフェースを
提供します。
フレームバッファはあなたが直接書くことができる
オフスクリーンサーフェスとして表現されます。
スクリーンに書いたものを画面に表示させるには、
画面の必要な部分が更新されることを保証する
@[更新|Screen.update_rect]関数を呼んで下さい。

Ruby/SDL のいかなるビデオ関連メソッドを呼ぶ前に、
最初に SDL.init(SDL::INIT_VIDEO)を呼ばなければいけません。
これは SDL 内のビデオとイベントを初期化します。

アプリケーションでサウンドとビデオを共に使うときは、
サウンドデバイスをオープンする前に
SDL.Init(SDL::INIT_AUDIO|SDL::INIT_VIDEO)
を呼ぶ必要があります。
そうしないと、Win32 の DirectX において
フルスクリーン表示モードにセットすることができないでしょう。

ライブラリを初期化した後は、ビデオ表示を順番にスタートさせることができます。
最も簡単な方法は、共通のスクリーン解像度とピクセル深度を選び、
エラーをチェックしつつビデオを初期化することです。
おそらくあなたが望んだものが得られるでしょうが、
SDL はあなたが求めたモードをエミュレートし、
更新の際に変換しているかもしれません。
最もよい方法は、
望まれるものに最も近いビデオモードを
@[問い合わせ|video_info]、
そのピクセルフォーマットに合わせて画像を
@[変換|Surface#display_format]することです。

SDL は現在 1 ピクセル 8 bit 以上のいかなるピクセル深度もサポートしています。
8 bpp のフォーマットは 8 bit のパレットモードとしてみなされ、
12, 15, 16, 24, そして 32 bpp は
「パックドピクセル」モードとしてみなされます。
これは、個々のピクセルが RGB 各チャンネルの輝度を
ピクセルのビットの中にパッキングして持っているということです。

ビデオモードを初期化した後は、
返値として得られたサーフェスに対し、他のフレームバッファのように書き込み、
いつものように更新処理を呼ぶことができます。

== SDL::Surface
== SDL::Screen
== SDL::VideoInfo
== 色、ピクセルフォーマット、ピクセル値について
%%%
NAME get_video_surface
TYPE .
PURPOSE 現在の表示サーフェスを返します。

PROTO
getVideoSurface
get_video_surface

DESC
このメソッドは現在の表示サーフェスを返します。
SDL が表示サーフェス上でフォーマット変換を行っている場合は、
この関数は実際のビデオサーフェスではなく、(SDL を使う側に
見せている) 変換前のサーフェスを返します。

RET
@[Screen]のインスタンスを返します。

EXCEPTION *

%%
NAME video_info
TYPE .
PURPOSE ビデオハードウェアについての情報を返します。

PROTO
videoInfo
video_info

DESC
この関数はビデオハードウェアに関する@[情報|VideoInfo]を返します。

@[set_video_mode]の前にこれが呼ばれると、
返されたオブジェクトのbppアトリビュートには
「最も適した」ビデオモードのピクセルフォーマットが入ります。

RET
情報を@[VideoInfo]のインスタンスで返します。

EXCEPTION *

SEEALSO
set_video_mode
VideoInfo

%%
NAME video_driver_name
TYPE .
PURPOSE ビデオドライバの名前を取得します。

PROTO
videoDriverName
video_driver_name

DESC
ドライバ名は "x11" や "windib" のように単なる 1 語の識別子です。

RET
ドライバ名を文字列で返します。

EXCEPTION
ビデオがまだ@[init]で初期化されていないなら例外@[Error]を発生させます。

SEEALSO
init

%%
NAME list_modes
TYPE .
PURPOSE 与えられたフォーマットとビデオのフラグに対し、利用可能な画面モードの配列を返します。

PROTO
list_modes(flags)
listModes(flags)

DESC
与えられたビデオのフラグに対し、
利用可能な画面モードの配列を返します。

フラグは@[set_video_mode]
で使われるものと同じであり、モードが有効かどうかを決定する際に
強い役割を果たします。
SDL::HWSURFACEをフラグとして渡すと、
ハードウェアのビデオサーフェスがサポートするモードだけが返されます。

RET
大きい方から小さい方にソートされています。
ある特定のフォーマットに対し利用可能なモードがない場合は
nil を返し、
与えられたフォーマットに対しどのモードでも OK の場合は
true を返します。
利用可能なモードが有限個しか存在しない場合は、
[縦方向の解像度, 横方向の解像度]という配列の配列を返します。

EXAMPLE
# 利用可能なフルスクリーンハードウェアモードを取得する
modes = SDL.list_modes(SDL::FULLSCREEN|SDL::HWSURFACE)

# 利用可能なモードがあるかどうかチェック
if modes == nil
  puts "利用可能なモードがありません!"
  exit 1
end

# 解像度が制限されているかどうかチェック
if modes == true
  puts "全解像度が利用可能です。"
else
  # 有効なモードを表示
  puts "利用可能なモード"
  modes.each{|w, h| puts "  #{w} x #{h}"}
end

SEEALSO
set_video_mode
video_info

%%
NAME check_video_mode
TYPE .
PURPOSE ある特定のビデオモードがサポートされているかチェックします。

PROTO
check_video_mode(w,h,bpp,flags)
checkVideoMode(w,h,bpp,flags)

DESC
要求されたモードがどのピクセル深度においてもサポートされていない場合は
0を返し、
あるいは与えられた横幅・高さと
要求された@[サーフェス|Surface] フラグ(@[set_video_mode]を見て下さい)
において利用可能な最も近いピクセル深度を返します。

ピクセル深度の値は推奨されるモードに過ぎません。
ビデオモードの@[設定|set_video_mode]時に
普通にあなたの望むピクセル深度を要求することができ、
SDL はシャドウビデオサーフェスを使ってそのピクセル深度を
エミュレートするでしょう。

EXAMPLE
puts "640x480@16bpp のモードをチェックしています。"
bpp = SDL.check_video_mode(640, 480, 16, SDL::HWSURFACE)
if bpp == 0
  puts "利用可能なモードではありません。"
  exit 1
end

puts "SDL は 640x480@#{bpp}bpp を推奨します。"
screen = SDL.set_video_mode(640, 480, bpp, SDL_HWSURFACE)

SEEALSO
set_video_mode
video_info

%%
NAME set_video_mode
TYPE .
PURPOSE 指定された横幅・高さ・ピクセル深度を用いてビデオモードを設定します。

PROTO
setVideoMode(w,h,bpp,flags)
set_video_mode(w,h,bpp,flags)

DESC
指定された幅・高さ・ピクセル深度(1ピクセルのビット数)を用いて
ビデオモードを設定します。
$[bpp] が 0 ならば、現在表示されているピクセル深度として扱われます。

$[flags] パラメータは@[Surface#flags]と同じです。
以下の値の OR による組み合わせが有効です。

:SDL::SWSURFACE
  システムメモリからビデオサーフェスを作成します。
:SDL::HWSURFACE
  ビデオメモリからビデオサーフェスを作成します。
:SDL::ASYNCBLIT
  表示サーフェスの非同期更新の使用を有効にします。
  これは通常、単一 CPU における blit 転送は遅くなりますが、
  SMP システムにおいてスピードの向上をもたらすかも知れません。
:SDL::ANYFORMAT
  普通は、もし要求されたピクセル深度のビデオサーフェス
  ($[bpp]) が使えない場合は、
  SDL はシャドウサーフェスでこれをエミュレートします。
  SDL::ANYFORMATはこれを禁止し、
  SDL はピクセル深度とは無関係にビデオサーフェスを使うことになります。
:SDL::HWPALETTE
  SDL がパレットに対する排他的なアクセスをできるようにします。
  このフラグがないと、
  @[Surface#set_colors]や@[Surface#set_palette]を用いて要求した色が、
  常に取得できるとは限りません。
:SDL::DOUBLEBUF
  ハードウェアによるダブルバッファを有効にします。
  (SDL::HWSURFACE と一緒の時のみ)
  @[Screen#flip] の呼び出し
  によってバッファを切り替え、画面を更新します。
  全ての描画は、その瞬間に表示されていない方のサーフェスに行われます。
  ダブルバッファを有効にできなかった場合は、
  @[Screen#flip] は画面全体に対し単に@[Screen#update_rect]を行います。
:SDL::FULLSCREEN
  SDL はフルスクリーンモードの使用を試みます。
  どういう理由であれ、ハードウェアによる解像度変更ができない場合は
  一段階解像度の高いモードが使われ、黒い背景の中央に表示ウインドウが置かれます。
:SDL::OPENGL
  OpenGL の描画コンテキストを作成します。
  前もって@[set_GL_attr]によって OpenGL のビデオ属性を
  設定しておく必要があります。
:SDL::OPENGLBLIT
  上と同様に OpenGL の描画コンテキストを作成しますが、
  通常の blit 転送を可能にします。
  画面(2D)のサーフェスはαチャンネルを持つことが可能で、
  画面のサーフェスへの変更を更新するために、
  @[Screen#update_rect]を使わなければいけません。
  注意: このオプションは互換性のためにのみ
  残されており、新しいコードでこの機能を使うことは
  ((*推奨されていません*))。
:SDL::RESIZABLE
  リサイズ可能なウィンドウを作成します。
  ユーザーの手でウィンドウがリサイズされた場合は、
  @[Event2::VideoResize]イベントが発生し、
  新しいサイズで @[set_video_mode]が再度呼ばれることがあります。
:SDL::NOFRAME
  もし可能であれば、
  SDL がタイトルバーなし、あるいはフレームによる装飾なしの
  ウィンドウが生成することになります。
  フルスクリーンモードの場合自動的にこのフラグを設定します。

NOTES
SDL.set_video_modeがどの$[flags]をを満たすことができたかは、
返り値のサーフェスの@[Surface#flags]にセットされています。

$[bpp] パラメータはピクセルごとのビット数です。
そのため、$[bpp] が 24 の場合は 3 バイト/ピクセルの
パッキングされた表現方法が使われます。
より一般的な 4 バイト/ピクセルのモードについては、
$[bpp] が 32 の場合に使われます。
幾分奇妙ですが、15 と 16 の場合はいずれも 2 バイト/ピクセルのモードを
要求しますが、異なるピクセルフォーマットです。

RET
フレームバッファのサーフェスを@[Screen]のインスタンスで返します。

EXCEPTION *
SEEALSO
Surface#lock
Surface#set_colors
Screen#flip
Screen

%%
NAME update_rect
MOD Screen
TYPE #
PURPOSE 与えられた領域の画面を更新します。

PROTO
updateRect(x,y,w,h)
update_rect(x,y,w,h)

DESC
与えられた領域の画面を更新します。
矩形は画面の境界内の収まっていなければなりません。
(つまりクリッピングはされません)

$[x]、$[y]、$[w]、$[h]がすべて 0 ならば、画面全体を更新します。

この関数は$[self]が@[ロック|Surface#lock]されている間は呼んでは
いけません。

SEEALSO
Surface#lock

%%
NAME flip
MOD Screen
TYPE #
PURPOSE スクリーンバッファを交換します。

PROTO
flip

DESC
ダブルバッファをサポートするハードウェアにおいて、
この関数は切替を設定して帰ってします。
ハードウェアは垂直帰線区間を待ち、
次のビデオサーフェスの blit 転送やロックが戻る前に
ビデオバッファを交換します。
ダブルバッファをサポートしないハードウェアにおいては、
$[self].update_rect(0, 0, 0, 0) を呼ぶのと同等です。

EXCEPTION *

SEEALSO
set_video_mode
Screen#update_rect

%%
NAME set_colors
MOD Surface
TYPE #
PURPOSE 与えられた 8 bit サーフェスのカラーマップの一部をセットします。

PROTO
set_colors(colors,firstcolor)
setColors(colors,firstcolor)

DESC
$[self] が現在の表示と関連付けられたサーフェスの場合は、
表示カラーマップは要求された色で更新されます。@[set_video_mode] フラグに
SDL::HWPALETTE がセットされていた場合は、
SDL::Surface#set_colors は常にtrueを返し、
ウィンドウのカラーマップが歪められていたり、
エミュレーションの下で動いている場合でも、
パレットはあなたが望んだ通りにセットされることが保証されています。

$[colors]として色情報の配列を与える必要があります。色情報とは
R、G、Bそれぞれ0から255までの値を持つ要素が3個の配列です。

SDL::HWPALETTE がセットされた、パレット化された(8 bit)
画面サーフェスには 2 種類のパレット、すなわち
サーフェスに対する(あるいはサーフェスからの)マッピング blit に
使われる論理パレットと、
ハードウェアが色を画面にどうマッピングするかを決定する物理パレット
とがあります。
SDL::Surface#SDL_set_colors は(存在するなら)双方のパレットを変更します。
これは (SDL::LOGPAL | SDL::PHYSPAL) を
$[flags] にセットして @[Surface#set_palette] を呼ぶのと同等です。

RET
$[self] がパレット化されたサーフェスではない場合は、
この関数は何もせず、false を返します。
全ての色がこのメソッドに
渡した通りにセットされた場合は、true を返します。
必ずしも全ての色エントリが与えられた通りにセットされた訳ではない場合は、
false を返すので、
実際の色パレットを決めるサーフェスパレットを見る必要があります。

EXAMPLE
# グレースケールのパレットでサーフェスを作成

# 色情報で埋める
colors = Array.new(256){|i| [i, i, i]}
# 表示サーフェスを作成
screen = SDL.set_video_mode(640, 480, 8, SDL::HWPALETTE)

# パレットのセット
screen.set_colors(colors, 0)

SEEALSO
Surface#set_palette
set_video_mode

%%
NAME set_palette
MOD Surface
TYPE #
PURPOSE 8 ビットサーフェスのパレットに色をセットします。

PROTO
set_palette(flags,colors,firstcolor)
setPalette(flags,colors,firstcolor)

DESC
与えられた 8 ビットサーフェスに対し、パレットの一部をセットします。

SDL::HWPALETTE フラグがセットされている
パレット(8ビット) の画面サーフェスには
2種類のパレットがあります。
すなわち、サーフェスからの(あるいはサーフェスに対する) blit 転送を
マッピングする論理パレットと、
ハードウェアが色を画面にマッピングする方法を決定する
物理パレットです。
@[blit_surface] は
サーフェスのピクセルフォーマット間で変換が必要な場合、
サーフェスを blit 転送する際に常に論理パレットを使います。
このため、さまざまな特殊色効果
(画面のフェード・カラーフラッシュ・画面の霞み)を得るために
パレットを片方だけ変更することはしばしば有用です。

この関数は
SDL::LOGPAL か SDL::PHYSPAL を
$[flags] に指定することで、
論理または物理パレットのいずれかを変更することができます。
$[self]が現在の表示と
関連付けられているサーフェスのときは、
表示のカラーマップは要求された色で更新されます。
@[set_video_mode] に
SDL::HWPALETTE がセットされていた場合は、
このメソッドは常に true を返し、
ウィンドウのカラーマップが歪められなければならない場合や、
エミュレーション下で動いている場合であっても、
パレットにはあなたが望んだ方法でセットされることが保証されます。

$[colors]として色情報の配列を与えます。色情報とは
R、G、Bそれぞれ0から255までの値を持つ要素が3個の配列です。
256**3 = 16777216色が使えます。

RET
$[self]がパレット化されたサーフェスでない場合は、
この関数は false を返して何もしません。
全ての色がこのメソッドに渡された通りにセットされると、
true を返します。
必ずしも全ての色エントリが与えられた通りにセットされた訳ではない場合は、
false を返すので、
実際の色パレットを決定するサーフェスパレットを見る必要があります。

EXAMPLE
# グレースケールのパレットでサーフェスを作成

# 色情報で埋める
colors = Array.new(256){|i| [i, i, i]}
# 表示サーフェスを作成
screen = SDL.set_video_mode(640, 480, 8, SDL::HWPALETTE)

# パレットのセット
screen.set_palette(SDL::LOGPAL|SDL::PHYSPAL, colors, 0)

SEEALSO
Surface#set_colors
set_video_mode

%%
NAME set_gamma
TYPE .
PURPOSE 表示用のカラーガンマ関数をセットします。

PROTO
set_gamma(redgamma,greengamma,bluegamma)
setGamma(redgamma,greengamma,bluegamma)

DESC
各カラーチャンネルについて、表示用の「ガンマ関数」をセットします。
ガンマは画面に表示される色の明るさ・コントラストを制御します。
ガンマ値 1.0 は単位元です。
(つまり、何の調整も行われません)

この関数は「ガンマ関数」のパラメータに基いてガンマを調整します。
@[set_gamma_ramp] を使うと、
ガンマ調整の参照テーブルを直接指定することができます。

EXCEPTION *
NOTES
全ての表示ハードウェアがガンマを変更することができるわけではありません。

SEEALSO
get_gamma_ramp
set_gamma_ramp

%%
NAME get_gamma_ramp
TYPE .
PURPOSE 表示のためのカラーガンマ値の変換テーブルを取得します。

PROTO
get_gamma_ramp
getGammaRamp

DESC
現在表示に使われているガンマ値の変換テーブルを取得します。
それぞれのテーブル(R, G, B)は 256 個の16bit符号なし整数値の配列です。

RET
3個の「256個の16bit符号なし整数値の配列」の配列を返します。

NOTES
全ての表示ハードウェアがガンマを変換できるわけではありません。

EXCEPTION *

SEEALSO
set_gamma
set_gamma_ramp

%%
NAME set_gamma_ramp
TYPE .
PURPOSE 表示用にカラーガンマの参照テーブルをセットします。

PROTO
set_gamma_ramp(table)
setGammaRamp(table)

DESC
各色チャンネルについて、表示用のガンマ参照テーブルをセットします。
引数 $[tables] は @[get_gamma_ramp] と同じフォーマットで、
対応するチャンネルの入力と出力間の写像を表現します。
入力は配列に対するインデックスであり、出力はそのインデックスにおける
16 ビットのガンマ値で、出力の色精度に合わせてスケーリングされます。

この関数は参照テーブルに基いてガンマを調整しますが、
@[set_gamma] を用いて
「ガンマ関数」パラメータに基いて計算されたガンマも持つことができます。

EXCEPTION *

SEEALSO
set_gamma
get_gamma_ramp

%%
NAME map_rgb
MOD Surface
TYPE #
PURPOSE RGB カラー値をピクセルフォーマットに写像します。

PROTO
map_rgb(r,g,b)
mapRGB(r,g,b)

DESC
RGB カラーの値を$[self]のピクセルフォーマットに写像し、
ピクセル値を 32bit 符号無し整数 として返します。
$[r]、$[g]、$[b] は0から255までの値をとれます。

フォーマットがパレット (8ビット) を持つ場合は、
パレット内において最も近い色のインデックスが返されます。

指定されたピクセルフォーマットがαチャンネルを持つ場合は、
全て 1 のビット(完全に不透明)として返されます。

RET
与えられたピクセルフォーマット上において、
与えられた RGB カラー値を最も良く近似するピクセル値です。
ピクセルフォーマットのピクセル深度が 32bpp より小さい場合は、
返値の使用されていない上位ビットは安全に無視することができます。
(例えば、16bpp のフォーマットでは返値は 2**16 より小さく、
8bpp では 2**8 より小さい)

SEEALSO
Surface#get_rgb
Surface#get_rgba
Surface#map_rgba
((<色、ピクセルフォーマット、ピクセル値について>))

%%
NAME map_rgba
MOD Surface
TYPE #
PURPOSE RGBA カラー値をピクセルフォーマットに写像します。

PROTO
map_rgba(r,g,b,a)
mapRGBA(r,g,b,a)

DESC
RGBA カラーの値を$[self]のピクセルフォーマットに写像し、
ピクセル値を 32bit 符号無し整数 として返します。
$[r]、$[g]、$[b]、$[a] は0から255までの値をとれます。

フォーマットがパレット (8ビット) を持つ場合は、
パレット内において最も近い色のインデックスが返されます。

指定されたピクセルフォーマットがαチャンネルを持たない場合は、
(パレットを持つフォーマットの中でそうであるように)
α値は無視されます。

RET
与えられたピクセルフォーマット上において、
与えられた RGBA カラー値を最も良く近似するピクセル値です。
ピクセルフォーマットのピクセル深度が 32bpp より小さい場合は、
返値の使用されていない上位ビットは安全に無視することができます。
(例えば、16bpp のフォーマットでは返値は 2**16 より小さく、
8bpp では 2**8 より小さい)

SEEALSO
Surface#get_rgb
Surface#get_rgba
Surface#map_rgb
((<色、ピクセルフォーマット、ピクセル値について>))

%%
NAME get_rgb
MOD Surface
TYPE #
PURPOSE 指定されたピクセルフォーマット内のピクセルから RGB 値を取得します。

PROTO
get_rgb(pixel)
getRGB(pixel)

DESC
$[self]のピクセルフォーマットによるピクセル値から
RGB 各チャンネルの値を要素数3の配列で取得します。

このメソッドは
RGB 各チャンネルが 8 ビット未満のピクセルフォーマットから
色チャンネルを変換する際にも 8 ビット全体 [0〜255] の範囲を使います。
(例えば、16 ビット RGB565 フォーマットにおける完全な白色は
[0xf8, 0xfc, 0xf8] ではなく [0xff, 0xff, 0xff] を返します)

SEEALSO
Surface#get_rgba
Surface#map_rgb
Surface#map_rgba
((<色、ピクセルフォーマット、ピクセル値について>))

%%
NAME get_rgba
MOD Surface
TYPE #
PURPOSE 指定されたピクセルフォーマット内のピクセルから RGBA 値を取得します。

PROTO
get_rgba(pixel)
getRGBA(pixel)

DESC
指定されたピクセルフォーマットに格納されたピクセルから
RGBA 各チャンネルの値を要素数4の配列で取得します。

RGB 各チャンネルが 8 ビット未満のピクセルフォーマットから
色チャンネルを変換する際にも 8 ビット全体 [0〜255] の範囲を使います。
(例えば、16 ビット RGB565 フォーマットにおける完全な白色は
[0xf8, 0xfc, 0xf8] ではなく [0xff, 0xff, 0xff] を返します)

サーフェスにαチャンネルがない場合は、αには 0xff (100% 不透明) が返されます。

SEEALSO
Surface#get_rgba
Surface#map_rgb
Surface#map_rgba
((<色、ピクセルフォーマット、ピクセル値について>))

%%
NAME new
MOD Surface
TYPE .
PURPOSE 空の @[Surface] のインスタンスを生成します。

PROTO
new(flags,w,h,depth,Rmask,Gmask,Bmask,Amask)

DESC
大きさが $[w] x $[h] の空のサーフェスを確保します。
(@[set_video_mode]の後で呼ばれなければいけません)

$[depth] が 8 ビットの場合は、
サーフェスに空のパレットが確保されます。
そうでない場合は、
与えられた$[Rmask]、$[Gmask]、$[Bmask]、$[Amask] を使って
「パッキングされたピクセル」が作られます。
$[flags] は作られるサーフェスのタイプを指定し、
以下の取りうる値の OR による組み合わせとなります。

:SDL::SWSURFACE
  SDL はシステムメモリからサーフェスを作ります。
  ピクセルレベルのアクセスのパフォーマンスを向上されますが、
  いくつかのハードウェアによる blit 転送の
  利点を得ることができなくなるかも知れません。
:SDL::HWSURFACE
  SDL はビデオメモリからサーフェスを作ろうとします。
  これにより SDL はビデオメモリ同士の bilt 転送
  (しばしばアクセラレーションが利きます) の利点を得ることができます。
:SDL::SRCCOLORKEY
  このフラグはサーフェスを blit する際にカラーキーを有効にします。
  SDL::HWSURFACE も指定されており、
  カラーキー付きの blit 転送もハードウェアによるアクセラレーションが利く場合は、
  SDL はサーフェスをビデオメモリに作ろうとします。
  サーフェスを作った後にこのフラグをセット・リセットしたい場合は
  @[Surface#set_color_key] を使って下さい。
:SDL::SRCALPHA
  このフラグはサーフェスからの blit 転送におけるαブレンディングを有効にします。
  SDL::HWSURFACE も指定され、
  αブレンディング blit 転送がハードウェアによるアクセラレーションが利く場合は
  サーフェスはなるだけビデオメモリに置かれます。
  サーフェスを作った後にこのフラグをセット・リセットしたい場合は
  @[Surface#set_alpha]を使って下さい。
RET
@[Surface]のインスタンスを返します。

EXCEPTION *

NOTES
αチャンネルが指定されている
(つまり $[Amask] が 0 でない) 場合は、
SDL::SRCALPHA フラグは自動的にセットされます。
サーフェスを作った後は、@[Surface#set_alpha]を
呼ぶことでこのフラグを取り除くことができます。

EXAMPLE
# テクスチャ用として OpenGL に要求される、
# 個々々のピクセルのバイトが RGBA の順番で並んだ
# 32 ビットのサーフェスを生成

big_endian = ([1].pack("N") == [1].pack("L"))

if big_endian
  rmask = 0xff000000
  gmask = 0x00ff0000
  bmask = 0x0000ff00
  amask = 0x000000ff
else
  rmask = 0x000000ff
  gmask = 0x0000ff00
  bmask = 0x00ff0000
  amask = 0xff000000
end

surface = SDL::Surface.new(SDL::SWSURFACE, width, height, 32,
                           rmask, gmask, bmask, amask);

SEEALSO
Surface.new_from
set_video_mode
Surface#lock
Surface#set_alpha
Surface#set_color_key

%%
NAME new_from
MOD Surface
TYPE .
PURPOSE ピクセルデータから @[Surface] のインスタンスを生成します。

PROTO
new_from(pixels,w,h,depth,pitch,Rmask,Gmask,Bmask,Amask)

DESC
与えられたピクセルデータ($[pixels])から @[Surface] のインスタンスを生成します。
$[pixels] に格納されたデータは
パラメータリストで指定された $[depth] のものであるとみなされます。
$[pitch] は各スキャンラインの長さ(バイト数)です。

他のパラメータについての詳しい記述については、@[Surface.new]を見てください。

RET
生成されたサーフェスを返します。

EXCEPTION *

SEEALSO
Surface.new

