= Video
TOC

SDL は表示フレームバッファに対するとてもシンプルなインターフェースを
提供します。
フレームバッファはあなたが直接書くことができる
オフスクリーンサーフェスとして表現されます。
スクリーンに書いたものを画面に表示させるには、
画面の必要な部分が更新されることを保証する
@[更新|Screen.update_rect]関数を呼んで下さい。

Ruby/SDL のいかなるビデオ関連メソッドを呼ぶ前に、
最初に SDL.init(SDL::INIT_VIDEO)を呼ばなければいけません。
これは SDL 内のビデオとイベントを初期化します。

アプリケーションでサウンドとビデオを共に使うときは、
サウンドデバイスをオープンする前に
SDL.Init(SDL::INIT_AUDIO|SDL::INIT_VIDEO)
を呼ぶ必要があります。
そうしないと、Win32 の DirectX において
フルスクリーン表示モードにセットすることができないでしょう。

ライブラリを初期化した後は、ビデオ表示を順番にスタートさせることができます。
最も簡単な方法は、共通のスクリーン解像度とピクセル深度を選び、
エラーをチェックしつつビデオを初期化することです。
おそらくあなたが望んだものが得られるでしょうが、
SDL はあなたが求めたモードをエミュレートし、
更新の際に変換しているかもしれません。
最もよい方法は、
望まれるものに最も近いビデオモードを
@[問い合わせ|video_info]、
そのピクセルフォーマットに合わせて画像を
@[変換|Surface#display_format]することです。

SDL は現在 1 ピクセル 8 bit 以上のいかなるピクセル深度もサポートしています。
8 bpp のフォーマットは 8 bit のパレットモードとしてみなされ、
12, 15, 16, 24, そして 32 bpp は
「パックドピクセル」モードとしてみなされます。
これは、個々のピクセルが RGB 各チャンネルの輝度を
ピクセルのビットの中にパッキングして持っているということです。

ビデオモードを初期化した後は、
返値として得られたサーフェスに対し、他のフレームバッファのように書き込み、
いつものように更新処理を呼ぶことができます。

%%%
NAME get_video_surface
TYPE .
PURPOSE 現在の表示サーフェスを返します。

PROTO
getVideoSurface
get_video_surface

DESC
このメソッドは現在の表示サーフェスを返します。
SDL が表示サーフェス上でフォーマット変換を行っている場合は、
この関数は実際のビデオサーフェスではなく、(SDL を使う側に
見せている) 変換前のサーフェスを返します。

RET
@[Screen]のインスタンスを返します。

EXCEPTION *

%%
NAME video_info
TYPE .
PURPOSE ビデオハードウェアについての情報を返します。

PROTO
videoInfo
video_info

DESC
この関数はビデオハードウェアに関する@[情報|VideoInfo]を返します。

@[set_video_mode]の前にこれが呼ばれると、
返されたオブジェクトのbppアトリビュートには
「最も適した」ビデオモードのピクセルフォーマットが入ります。

RET
情報を@[VideoInfo]のインスタンスで返します。

EXCEPTION *

SEEALSO
set_video_mode
VideoInfo

%%
NAME video_driver_name
TYPE .
PURPOSE ビデオドライバの名前を取得します。

PROTO
videoDriverName
video_driver_name

DESC
ドライバ名は "x11" や "windib" のように単なる 1 語の識別子です。

RET
ドライバ名を文字列で返します。

EXCEPTION
ビデオがまだ@[init]で初期化されていないなら例外@[Error]を発生させます。

SEEALSO
init

%%
NAME list_modes
TYPE .
PURPOSE 与えられたフォーマットとビデオのフラグに対し、利用可能な画面モードの配列を返します。

PROTO
list_modes(flags)
listModes(flags)

DESC
与えられたビデオのフラグに対し、
利用可能な画面モードの配列を返します。

フラグは@[set_video_mode]
で使われるものと同じであり、モードが有効かどうかを決定する際に
強い役割を果たします。
SDL::HWSURFACEをフラグとして渡すと、
ハードウェアのビデオサーフェスがサポートするモードだけが返されます。

RET
大きい方から小さい方にソートされています。
ある特定のフォーマットに対し利用可能なモードがない場合は
nil を返し、
与えられたフォーマットに対しどのモードでも OK の場合は
true を返します。
利用可能なモードが有限個しか存在しない場合は、
[縦方向の解像度, 横方向の解像度]という配列の配列を返します。

EXAMPLE
# 利用可能なフルスクリーンハードウェアモードを取得する
modes = SDL.list_modes(SDL::FULLSCREEN|SDL::HWSURFACE)

# 利用可能なモードがあるかどうかチェック
if modes == nil
  puts "利用可能なモードがありません!"
  exit 1
end

# 解像度が制限されているかどうかチェック
if modes == true
  puts "全解像度が利用可能です。"
else
  # 有効なモードを表示
  puts "利用可能なモード"
  modes.each{|w, h| puts "  #{w} x #{h}"}
end

SEEALSO
set_video_mode
video_info

%%
NAME check_video_mode
TYPE .
PURPOSE ある特定のビデオモードがサポートされているかチェックします。

PROTO
check_video_mode(w,h,bpp,flags)
checkVideoMode(w,h,bpp,flags)

DESC
要求されたモードがどのピクセル深度においてもサポートされていない場合は
0を返し、
あるいは与えられた横幅・高さと
要求された@[サーフェス|Surface] フラグ(@[set_video_mode]を見て下さい)
において利用可能な最も近いピクセル深度を返します。

ピクセル深度の値は推奨されるモードに過ぎません。
ビデオモードの@[設定|set_video_mode]時に
普通にあなたの望むピクセル深度を要求することができ、
SDL はシャドウビデオサーフェスを使ってそのピクセル深度を
エミュレートするでしょう。

EXAMPLE
puts "640x480@16bpp のモードをチェックしています。"
bpp = SDL.check_video_mode(640, 480, 16, SDL::HWSURFACE)
if bpp == 0
  puts "利用可能なモードではありません。"
  exit 1
end

puts "SDL は 640x480@#{bpp}bpp を推奨します。"
screen = SDL.set_video_mode(640, 480, bpp, SDL_HWSURFACE)

SEEALSO
set_video_mode
video_info

%%
NAME set_video_mode
TYPE .
PURPOSE 指定された横幅・高さ・ピクセル深度を用いてビデオモードを設定します。

PROTO
setVideoMode(w,h,bpp,flags)
set_video_mode(w,h,bpp,flags)

DESC
指定された幅・高さ・ピクセル深度(1ピクセルのビット数)を用いて
ビデオモードを設定します。
$[bpp] が 0 ならば、現在表示されているピクセル深度として扱われます。

$[flags] パラメータは@[Surface#flags]と同じです。
以下の値の OR による組み合わせが有効です。

:SDL::SWSURFACE
  システムメモリからビデオサーフェスを作成します。
:SDL::HWSURFACE
  ビデオメモリからビデオサーフェスを作成します。
:SDL::ASYNCBLIT
  表示サーフェスの非同期更新の使用を有効にします。
  これは通常、単一 CPU における blit 転送は遅くなりますが、
  SMP システムにおいてスピードの向上をもたらすかも知れません。
:SDL::ANYFORMAT
  普通は、もし要求されたピクセル深度のビデオサーフェス
  ($[bpp]) が使えない場合は、
  SDL はシャドウサーフェスでこれをエミュレートします。
  SDL::ANYFORMATはこれを禁止し、
  SDL はピクセル深度とは無関係にビデオサーフェスを使うことになります。
:SDL::HWPALETTE
  SDL がパレットに対する排他的なアクセスをできるようにします。
  このフラグがないと、
  @[Surface#set_colors]や@[Surface#set_palette]を用いて要求した色が、
  常に取得できるとは限りません。
:SDL::DOUBLEBUF
  ハードウェアによるダブルバッファを有効にします。
  (SDL::HWSURFACE と一緒の時のみ)
  @[Screen#flip] の呼び出し
  によってバッファを切り替え、画面を更新します。
  全ての描画は、その瞬間に表示されていない方のサーフェスに行われます。
  ダブルバッファを有効にできなかった場合は、
  @[Screen#flip] は画面全体に対し単に@[Screen#update_rect]を行います。
:SDL::FULLSCREEN
  SDL はフルスクリーンモードの使用を試みます。
  どういう理由であれ、ハードウェアによる解像度変更ができない場合は
  一段階解像度の高いモードが使われ、黒い背景の中央に表示ウインドウが置かれます。
:SDL::OPENGL
  OpenGL の描画コンテキストを作成します。
  前もって@[set_GL_attr]によって OpenGL のビデオ属性を
  設定しておく必要があります。
:SDL::OPENGLBLIT
  上と同様に OpenGL の描画コンテキストを作成しますが、
  通常の blit 転送を可能にします。
  画面(2D)のサーフェスはαチャンネルを持つことが可能で、
  画面のサーフェスへの変更を更新するために、
  @[Screen#update_rect]を使わなければいけません。
  注意: このオプションは互換性のためにのみ
  残されており、新しいコードでこの機能を使うことは
  ((*推奨されていません*))。
:SDL::RESIZABLE
  リサイズ可能なウィンドウを作成します。
  ユーザーの手でウィンドウがリサイズされた場合は、
  @[Event2::VideoResize]イベントが発生し、
  新しいサイズで @[set_video_mode]が再度呼ばれることがあります。
:SDL::NOFRAME
  もし可能であれば、
  SDL がタイトルバーなし、あるいはフレームによる装飾なしの
  ウィンドウが生成することになります。
  フルスクリーンモードの場合自動的にこのフラグを設定します。

NOTES
SDL.set_video_modeがどの$[flags]をを満たすことができたかは、
返り値のサーフェスの@[Surface#flags]にセットされています。

$[bpp] パラメータはピクセルごとのビット数です。
そのため、$[bpp] が 24 の場合は 3 バイト/ピクセルの
パッキングされた表現方法が使われます。
より一般的な 4 バイト/ピクセルのモードについては、
$[bpp] が 32 の場合に使われます。
幾分奇妙ですが、15 と 16 の場合はいずれも 2 バイト/ピクセルのモードを
要求しますが、異なるピクセルフォーマットです。

RET
フレームバッファのサーフェスを@[Screen]のインスタンスで返します。

EXCEPTION *
SEEALSO
Surface#lock
Surface#set_colors
Screen#flip
Screen

%%
NAME update_rect
MOD Screen
TYPE #
PURPOSE 与えられた領域の画面を更新します。

PROTO
updateRect(x,y,w,h)
update_rect(x,y,w,h)

DESC
与えられた領域の画面を更新します。
矩形は画面の境界内の収まっていなければなりません。
(つまりクリッピングはされません)

$[x]、$[y]、$[w]、$[h]がすべて 0 ならば、画面全体を更新します。

この関数は$[self]が@[ロック|Surface#lock]されている間は呼んでは
いけません。

SEEALSO
Surface#lock

%%
NAME flip
MOD Screen
TYPE #
PURPOSE スクリーンバッファを交換します。

PROTO
flip

DESC
ダブルバッファをサポートするハードウェアにおいて、
この関数は切替を設定して帰ってします。
ハードウェアは垂直帰線区間を待ち、
次のビデオサーフェスの blit 転送やロックが戻る前に
ビデオバッファを交換します。
ダブルバッファをサポートしないハードウェアにおいては、
$[self].update_rect(0, 0, 0, 0) を呼ぶのと同等です。

EXCEPTION *

SEEALSO
set_video_mode
Screen#update_rect

%%
NAME set_colors
MOD Surface
TYPE #
PURPOSE 与えられた 8 bit サーフェスのカラーマップの一部をセットします。

PROTO
set_colors(colors,firstcolor)
setColors(colors,firstcolor)

DESC
$[self] が現在の表示と関連付けられたサーフェスの場合は、
表示カラーマップは要求された色で更新されます。@[set_video_mode] フラグに
SDL::HWPALETTE がセットされていた場合は、
SDL::Surface#set_colors は常にtrueを返し、
ウィンドウのカラーマップが歪められていたり、
エミュレーションの下で動いている場合でも、
パレットはあなたが望んだ通りにセットされることが保証されています。

$[colors]として色情報の配列を与える必要があります。色情報とは
R、G、Bそれぞれ0から255までの値を持つ要素が3個の配列です。

SDL::HWPALETTE がセットされた、パレット化された(8 bit)
画面サーフェスには 2 種類のパレット、すなわち
サーフェスに対する(あるいはサーフェスからの)マッピング blit に
使われる論理パレットと、
ハードウェアが色を画面にどうマッピングするかを決定する物理パレット
とがあります。
SDL::Surface#SDL_set_colors は(存在するなら)双方のパレットを変更します。
これは (SDL::LOGPAL | SDL::PHYSPAL) を
$[flags] にセットして @[Surface#set_palette] を呼ぶのと同等です。

RET
$[self] がパレット化されたサーフェスではない場合は、
この関数は何もせず、false を返します。
全ての色がこのメソッドに
渡した通りにセットされた場合は、true を返します。
必ずしも全ての色エントリが与えられた通りにセットされた訳ではない場合は、
false を返すので、
実際の色パレットを決めるサーフェスパレットを見る必要があります。

EXAMPLE
# グレースケールのパレットでサーフェスを作成

# 色情報で埋める
colors = Array.new(256){|i| [i, i, i]}
# 表示サーフェスを作成
screen = SDL.set_video_mode(640, 480, 8, SDL::HWPALETTE)

# パレットのセット
screen.set_colors(colors, 0)

SEEALSO
Surface#set_palette
set_video_mode

%%
NAME set_palette
MOD Surface
TYPE #
PURPOSE 8 ビットサーフェスのパレットに色をセットします。

PROTO
set_palette(flags,colors,firstcolor)
setPalette(flags,colors,firstcolor)

与えられた 8 ビットサーフェスに対し、パレットの一部をセットします。

SDL::HWPALETTE フラグがセットされている
パレット(8ビット) の画面サーフェスには
2種類のパレットがあります。
すなわち、サーフェスからの(あるいはサーフェスに対する) blit 転送を
マッピングする論理パレットと、
ハードウェアが色を画面にマッピングする方法を決定する
物理パレットです。
@[blit_surface] は
サーフェスのピクセルフォーマット間で変換が必要な場合、
サーフェスを blit 転送する際に常に論理パレットを使います。
このため、さまざまな特殊色効果
(画面のフェード・カラーフラッシュ・画面の霞み)を得るために
パレットを片方だけ変更することはしばしば有用です。

この関数は
SDL::LOGPAL か SDL::PHYSPAL を
$[flags] に指定することで、
論理または物理パレットのいずれかを変更することができます。
$[self]が現在の表示と
関連付けられているサーフェスのときは、
表示のカラーマップは要求された色で更新されます。
@[set_video_mode] に
SDL::HWPALETTE がセットされていた場合は、
このメソッドは常に true を返し、
ウィンドウのカラーマップが歪められなければならない場合や、
エミュレーション下で動いている場合であっても、
パレットにはあなたが望んだ方法でセットされることが保証されます。

$[colors]として色情報の配列を与えます。色情報とは
R、G、Bそれぞれ0から255までの値を持つ要素が3個の配列です。
256**3 = 16777216色が使えます。

RET
$[self]がパレット化されたサーフェスでない場合は、
この関数は false を返して何もしません。
全ての色がこのメソッドに渡された通りにセットされると、
true を返します。
必ずしも全ての色エントリが与えられた通りにセットされた訳ではない場合は、
false を返すので、
実際の色パレットを決定するサーフェスパレットを見る必要があります。

EXAMPLE
# グレースケールのパレットでサーフェスを作成

# 色情報で埋める
colors = Array.new(256){|i| [i, i, i]}
# 表示サーフェスを作成
screen = SDL.set_video_mode(640, 480, 8, SDL::HWPALETTE)

# パレットのセット
screen.set_palette(SDL::LOGPAL|SDL::PHYSPAL, colors, 0)

SEEALSO
Surface#set_colors
set_video_mode

%%