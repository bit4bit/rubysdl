= Event

== Event system概要
イベント処理によってあなたのアプリケーションはユーザーからの
入力を受け取ることができます。
イベント処理は次のメソッドを呼ぶことで、(ビデオと一緒に)初期化されます。
  SDL.init(SDL::INIT_VIDEO)
内部的には、SDL は処理されるまで待機している全てのイベントをイベントキューに
格納します。

@[Event2.poll] や @[Event2.wait] のようなメソッドを使うことで、
待機している入力イベントを見たり、処理することができます。

Ruby/SDLにおけるイベント処理の鍵は、@[Event2]のサブクラス群です。
イベントキュー自身は@[Event2](のサブクラス)のインスタンスの列と
みなすことができます。それらのオブジェクトは@[Event2.poll]を使って
キューから読みだされ、
そしてそこに格納された情報の処理をアプリケーションがします。

@[Event2]のサブクラスは以下の通りです。
* @[Event2::Active]
* @[Event2::KeyDown]
* @[Event2::KeyUp]
* @[Event2::MouseMotion]
* @[Event2::MouseButtonDown]
* @[Event2::MouseButtonUp]
* @[Event2::JoyAxis]
* @[Event2::JoyBall]
* @[Event2::JoyHat]
* @[Event2::JoyButtonUp]
* @[Event2::JoyButtonDown]
* @[Event2::Quit]
* @[Event2::SysWM]
* @[Event2::VideoResize]

イベントクラスには以下の二つの用途があります。
* キューからイベントを読み出す
* キューにイベントを登録する

キューからイベントを読み出すには、 @[Event2.poll] を使います。
ここでは、 @[Event2.poll] を使った例を示します。
  while event = SDL::Event2.poll
@[Event2.poll] はイベントキューから次のイベントを
取り出して、キューから削除します。キューにイベントがないときは
nil を返し、それ以外の場合は上に挙げたイベントクラスのインスタンス
を返します。

次に、イベントの種類を判別するために case〜when 文を使います。
    case event
次に、どの種類のイベントを知りたいのかということと、起こった
イベントの種類を知らなければいけません。
ここでは、アプリケーション内のマウスポインタの動きを知りたいとします。
求めているイベントに対応するクラスは@[Event2::MouseMotion]
であることがわかります。case〜when 文の when の所にクラスを書くと、
そのクラスのインスタンスをcaseに与えたときに分岐することうぃ利用します
  when SDL::Event2::MouseMotion
ここでは event は @[Event2::MouseMotion] のインスタンスなので
そのメソッドを使って情報を得ることができます。
      puts "マウスカーソルが移動するイベントを受信しました。"
      puts "カーソルの位置は(#{event.x}, #{event.y})です。"
    else
      puts "ハンドルしていないイベントです!"
    end
  end
  puts "イベントキューは空です。"

イベントキューにイベントを送ることもできますので、
イベントキューを双方向通信に利用することもできます。
@[Event2.push]でイベントキューにイベントを送ることができます。
偽の入力イベントを作り出したりするために使うことができます。
ユーザイベントは Ruby/SDL では利用できません。

== SDL::Event2
イベントを取り扱うためのクラスです。実際のクラスはこのクラスのサブクラス
として表されます。

Event2という名前は互換性のためのものです。これが気にいらない場合は、
ライブラリ読み込みの直後に
  module SDL
    remove_const :Event2
    Event = Event2
  end
と書いてください。これで SDL::Event という名前で SDL::Event2 に
アクセスできます。

