= Event

== Event system概要
イベント処理によってあなたのアプリケーションはユーザーからの
入力を受け取ることができます。
イベント処理は次のメソッドを呼ぶことで、(ビデオと一緒に)初期化されます。
  SDL.init(SDL::INIT_VIDEO)
内部的には、SDL は処理されるまで待機している全てのイベントをイベントキューに
格納します。

@[Event2.poll] や @[Event2.wait] のようなメソッドを使うことで、
待機している入力イベントを見たり、処理することができます。

Ruby/SDLにおけるイベント処理の鍵は、@[Event2]のサブクラス群です。
イベントキュー自身は@[Event2](のサブクラス)のインスタンスの列と
みなすことができます。それらのオブジェクトは@[Event2.poll]を使って
キューから読みだされ、
そしてそこに格納された情報の処理をアプリケーションがします。

@[Event2]のサブクラスは以下の通りです。
* @[Event2::Active]
* @[Event2::KeyDown]
* @[Event2::KeyUp]
* @[Event2::MouseMotion]
* @[Event2::MouseButtonDown]
* @[Event2::MouseButtonUp]
* @[Event2::JoyAxis]
* @[Event2::JoyBall]
* @[Event2::JoyHat]
* @[Event2::JoyButtonUp]
* @[Event2::JoyButtonDown]
* @[Event2::Quit]
* @[Event2::SysWM]
* @[Event2::VideoResize]

イベントクラスには以下の二つの用途があります。
* キューからイベントを読み出す
* キューにイベントを登録する

キューからイベントを読み出すには、 @[Event2.poll] を使います。
ここでは、 @[Event2.poll] を使った例を示します。
  while event = SDL::Event2.poll
@[Event2.poll] はイベントキューから次のイベントを
取り出して、キューから削除します。キューにイベントがないときは
nil を返し、それ以外の場合は上に挙げたイベントクラスのインスタンス
を返します。

次に、イベントの種類を判別するために case〜when 文を使います。
    case event
次に、どの種類のイベントを知りたいのかということと、起こった
イベントの種類を知らなければいけません。
ここでは、アプリケーション内のマウスポインタの動きを知りたいとします。
求めているイベントに対応するクラスは@[Event2::MouseMotion]
であることがわかります。case〜when 文の when の所にクラスを書くと、
そのクラスのインスタンスをcaseに与えたときに分岐することうぃ利用します
  when SDL::Event2::MouseMotion
ここでは event は @[Event2::MouseMotion] のインスタンスなので
そのメソッドを使って情報を得ることができます。
      puts "マウスカーソルが移動するイベントを受信しました。"
      puts "カーソルの位置は(#{event.x}, #{event.y})です。"
    else
      puts "ハンドルしていないイベントです!"
    end
  end
  puts "イベントキューは空です。"

イベントキューにイベントを送ることもできますので、
イベントキューを双方向通信に利用することもできます。
@[Event2.push]でイベントキューにイベントを送ることができます。
偽の入力イベントを作り出したりするために使うことができます。
ユーザイベントは Ruby/SDL では利用できません。

== SDL::Event2
イベントを取り扱うためのクラスです。実際のクラスはこのクラスのサブクラス
として表されます。

Event2という名前は互換性のためのものです。これが気にいらない場合は、
ライブラリ読み込みの直後に
  module SDL
    remove_const :Event2
    Event = Event2
  end
と書いてください。これで SDL::Event という名前で SDL::Event2 に
アクセスできます。

== SDL::Event2::Active
アプリケーションの可視性に関するイベントのクラスです。

マウスカーソルのウインドウの出入り、
キーボードフォーカスの得失、および
最小化/アイコン化されたり元に戻ったときに発生します。

上のいずれが生じたのかは @[Event2::Active#state] でわかります。

* NOTES

  このイベントは、最初にウィンドウが作成されたときには発生しません。

METHODS(Event2::Active)

== SDL::Event2::KeyDown
キーボードを押したときに発生するイベントのクラスです。

METHODS(Event2::KeyDown)

== SDL::Event2::KeyUp
キーボードを離したときに発生するイベントのクラスです。

METHODS(Event2::KeyUp)

== SDL::Event2::MouseMotion
== SDL::Event2::MouseButtonDown
== SDL::Event2::MouseButtonUp
== SDL::Event2::JoyAxis
== SDL::Event2::JoyBall
== SDL::Event2::JoyHat
== SDL::Event2::JoyButtonUp
== SDL::Event2::JoyButtonDown
== SDL::Event2::Quit
== SDL::Event2::SysWM
== SDL::Event2::VideoResize

== Methods
%%%
NAME poll
MOD Event2
TYPE .
PURPOSE 現在留まっているイベントを取り出します。
RVAL Event2/nil

PROTO
poll

DESC
現在留まっているイベントを取り出し、イベントがあるときはそのイベントを、
無いときは nil を返します。イベントが取り出されたときは
キューからそのイベントを削除します。

EXAMPLE
while event = SDL::Event2.poll #キューに残っているイベントがなくなるまでループ
  case event # 適切なイベントタイプを処理
  when SDL::Event2::KeyDown # キー押下イベントを処理
    puts "あ! キーを押しましたね"
  when SDL::Event2::MouseMotion
    .
    .
    .
  else # 未処理のイベントを報告
    puts 私にはよく分からないイベントです!"
  end
end

SEEALSO
Event2
Event2.wait

%%
NAME wait
MOD Event2
TYPE .
PURPOSE 次の利用可能なイベントが来るまで無限に待機します。
RVAL Event2/nil

PROTO
wait

DESC
次の利用可能なイベントが来るまで無限に待機し、
イベントが来たらそのイベントを返します。

返したイベントはキューから削除されます。

EXCEPTION
イベントを待っている間にエラーがあった場合は例外 @[Error] を
発生させます。

SEEALSO
Event2.poll

%%
NAME push
MOD Event2
TYPE .
PURPOSE イベントをイベントキューにプッシュします。

PROTO
push(event)

DESC
$[event] で指定したイベントをイベントキューにプッシュします。

NOTES
デバイス入力イベントをキューにプッシュしても、
SDL 内のデバイスの状態は変わりません。

EXCEPTION *

SEEALSO
Event2.poll

%%
NAME app_state
MOD Event2
TYPE .
PURPOSE アプリケーションの状態を得ます。
RVAL UINT

PROTO
app_state
appState

DESC
アプリケーションの現在の状態を返します。戻り値は以下のビット和です。
:SDL::Event2::APPMOUSEFOCUS
  マウスのフォーカスがあります。
:SDL::Event2::APPINPUTFOCUS
  キーボードのフォーカスがあります。
:SDL::Event2::APPACTIVE
  アプリケーションは可視状態です。

SEEALSO
Event2::Active

%%
NAME enable_unicode
MOD Event2
TYPE .
PURPOSE UNICODE変換を有効にします。

PROTO
enable_unicode
enableUNICODE

DESC
キーイベントに対応した文字コードを得るために、
まずこの関数を呼び出してUnicode変換を有効にしなければいけません。
変換を有効にすると、キーボードイベントのたびにちょっとした
オーバーヘッドが発生するため、デフォルトでは変換は無効になっています。
変換を有効にすると、以後のキーダウンイベントでは、
@[Event2::KeyDown#unicode] から対応する文字コードが得られます。
対応する文字コードが見つからないときは0が入ります。

NOTES
変換が有効なのはキーダウンイベントのみです。
キーリリースイベントは変換されません。

SEEALSO
Event2.disable_unicode
Event2.enable_unicode?

%%
NAME disable_unicode
MOD Event2
TYPE .
PURPOSE UNICODE変換を無効にします。

PROTO
disable_unicode
disableUNICODE

DESC
UNICODE変換を無効にします。詳しくは @[Event2.enable_unicode]
を見てください。

%%
NAME enable_unicode?
MOD Event2
TYPE .
PURPOSE UNICODE変換が有効かどうか調べます。
RVAL true/false

PROTO
enable_unicode?
enableUNICODE?

DESC
UNICODE変換が有効かどうか調べます。詳しくは @[Event2.enable_unicode]
を見てください。

%%
NAME gain
TYPE #
MOD Event2::Active
PURPOSE 可視性を得たなら true を、失ったなら false を返します。
RVAL true/false

PROTO
gain

DESC
可視性を得たことに対応するイベントなら true を、
失ったことに対応するイベントなら false を返します。

SEEALSO
Event2::Active
Event2::Active#state

%%
NAME state
MOD Event2::Active
TYPE #
PURPOSE どのような種類の可視性変更イベントが発生したのかを返します。
RVAL SDL::Event2::APPMOUSEFOCUS/SDL::Event2::APPINPUTFOCUS/SDL::Event2::APPACTIVE

PROTO
state

DESC
マウスカーソルがウインドウの外に出たり(gain=false)、ウインドウ内に
入ったり(gain=true)したときは、SDL::Event2::APPMOUSEFOCUS を返します。

アプリケーションがキーボードフォーカスを得たり(gain=true)
失ったり(gain=false)したときは、SDL::Event2::APPINPUTFOCUS を
返します。これは通常他のアプリケーションがアクティブに
なったときに発生します。

アプリケーションが最小化/アイコン化されたり(gain=false)
元に戻ったとき(gain=true)には SDL::Event2::APPACTIVE を返します。

SEEALSO
Event2::Active
Event2::Active#gain

%%
NAME press
MOD Event2::KeyDown
TYPE #
PURPOSE trueを返します。
RVAL true

PROTO
press

DESC
常に true を返します。

SEEALSO
Event2::KeyUp#press

%%
NAME sym
MOD Event2::KeyDown
TYPE #
PURPOSE 何のキーを押したかをキーシンボルで返します。
RVAL Integer

PROTO
sym

DESC
何のキーを押したかを((<キーシンボル>))で返します。

SEEALSO
Event2::KeyDown#unicode

%%
NAME mod
MOD Event2::KeyDown
TYPE #
PURPOSE キー押下時のキーモディファイアの状態を返します。
RVAL UINT

PROTO
mod

DESC
キー押下時のキーモディファイアの状態を返します。
返り値は @[Key.mod_state] で得られるものと同じです。

SEEALSO
Key.mod_state

%%
NAME unicode
MOD Event2::KeyDown
TYPE #
PURPOSE 変換された文字を返します。
RVAL UINT

PROTO
unicode

DESC
@[Event2.enable_unicode] によって UNICODE 変換が有効にされた時には、
キーの押下に対応する UNICODE 文字を返します。
文字の上位 9 ビットが 0 の場合は、 ASCII 文字に対応しています。

変換が有効でない場合には0 を返します。

%%
NAME press
MOD Event2::KeyUp
TYPE #
PURPOSE falseを返します。
RVAL false

PROTO
press

DESC
常に false を返します。

SEEALSO
Event2::KeyDown#press

%%
NAME sym
MOD Event2::KeyUp
TYPE #
PURPOSE 何のキーを離したかをキーシンボルで返します。
RVAL Integer

PROTO
sym

DESC
何のキーを離したかを((<キーシンボル>))で返します。

%%
NAME mod
MOD Event2::KeyUp
TYPE #
PURPOSE キーモディファイアの状態を返します。
RVAL UINT

PROTO
mod

DESC
キーモディファイアの状態を返します。
返り値は @[Key.mod_state] で得られるものと同じです。

SEEALSO
Key.mod_state

